/*:
 
 */
//: Array (æœ‰åºå€¼)
let emptyArr = [Int]()
let literalArr = [1, 1]

//: Dictionary (æ— åºå”¯ä¸€å€¼)
let emptyDic = [String: AnyObject]()
var literalDic = [1: "1", 2: "2"] // [1: "1", 1: "2"]
literalDic.updateValue("1", forKey: 2)
literalDic.removeValue(forKey: 2)
literalDic[2] = "3"
literalDic.keys.sorted()

//: Set (æ— åºé”®å€¼å¯¹)
let emptySet = Set<Int>()
let literalSet: Set = [1, 1]
/*:
 * ä½¿ç”¨ intersection(_:)æ–¹æ³•æ¥åˆ›å»ºä¸€ä¸ªåªåŒ…å«ä¸¤ä¸ªåˆé›†å…±æœ‰å€¼çš„æ–°åˆé›†ï¼›
 * ä½¿ç”¨ symmetricDifference(_:)æ–¹æ³•æ¥åˆ›å»ºä¸€ä¸ªåªåŒ…å«ä¸¤ä¸ªåˆé›†å„è‡ªæœ‰çš„éå…±æœ‰å€¼çš„æ–°åˆé›†ï¼›
 * ä½¿ç”¨ union(_:)æ–¹æ³•æ¥åˆ›å»ºä¸€ä¸ªåŒ…å«ä¸¤ä¸ªåˆé›†æ‰€æœ‰å€¼çš„æ–°åˆé›†ï¼›
 * ä½¿ç”¨ subtracting(_:)æ–¹æ³•æ¥åˆ›å»ºä¸€ä¸ªä¸¤ä¸ªåˆé›†å½“ä¸­ä¸åŒ…å«æŸä¸ªåˆé›†å€¼çš„æ–°åˆé›†ã€‚
 */
let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]

oddDigits.union(evenDigits).sorted()
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
oddDigits.intersection(evenDigits).sorted()
// []
oddDigits.subtracting(singleDigitPrimeNumbers).sorted()
// [1, 9]
oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()
// [1, 2, 9]
/*:
 * ä½¿ç”¨â€œç›¸ç­‰â€è¿ç®—ç¬¦ ( == )æ¥åˆ¤æ–­ä¸¤ä¸ªåˆé›†æ˜¯å¦åŒ…å«æœ‰ç›¸åŒçš„å€¼ï¼›
 * ä½¿ç”¨ isSubset(of:) æ–¹æ³•æ¥ç¡®å®šä¸€ä¸ªåˆé›†çš„æ‰€æœ‰å€¼æ˜¯è¢«æŸåˆé›†åŒ…å«ï¼›
 * ä½¿ç”¨ isSuperset(of:)æ–¹æ³•æ¥ç¡®å®šä¸€ä¸ªåˆé›†æ˜¯å¦åŒ…å«æŸä¸ªåˆé›†çš„æ‰€æœ‰å€¼ï¼›
 * ä½¿ç”¨ isStrictSubset(of:) æˆ–è€… isStrictSuperset(of:)æ–¹æ³•æ¥ç¡®å®šæ˜¯ä¸ªåˆé›†æ˜¯å¦ä¸ºæŸä¸€ä¸ªåˆé›†çš„å­é›†æˆ–è€…è¶…é›†ï¼Œä½†å¹¶ä¸ç›¸ç­‰ï¼›
 * ä½¿ç”¨ isDisjoint(with:)æ–¹æ³•æ¥åˆ¤æ–­ä¸¤ä¸ªåˆé›†æ˜¯å¦æ‹¥æœ‰å®Œå…¨ä¸åŒçš„å€¼ã€‚
 */
let houseAnimals: Set = ["ğŸ¶", "ğŸ±"]
let farmAnimals: Set = ["ğŸ®", "ğŸ”", "ğŸ‘", "ğŸ¶", "ğŸ±"]
let cityAnimals: Set = ["ğŸ¦", "ğŸ­"]

houseAnimals.isSubset(of: farmAnimals)
// true
farmAnimals.isSuperset(of: houseAnimals)
// true
farmAnimals.isDisjoint(with: cityAnimals)
// true
//: [Contents](Contents) | [Previous](@previous) | [Next](@next)


